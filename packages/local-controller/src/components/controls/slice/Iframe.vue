<template>
	<div class="slice-iframe">
		<h3 class="heading-h2">{{ names.slice }}</h3>
		<figure class="mt-2 text-black-300 rounded border border-gray h-[calc(100vh-120px)] flex flex-col">
			<figcaption class="h-12 flex items-center px-4 border-b border-gray">
				<h4 class="font-medium text-sm">{{ names.variation }}</h4>
			</figcaption>
			<div ref="container" class="w-full flex-1 relative overflow-auto">
				<iframe ref="iframe" :src="src" frameborder="0" class="w-full pointer-events-none"></iframe>
			</div>
		</figure>
	</div>
</template>

<script setup lang="ts">
import { computed, onMounted, ref, toRaw, watch, watchEffect } from "vue";

import { RendererClient } from "@prismicio/slice-canvas-com";

import { state as rendererState, setLibraries, setCurrent } from "~/store/renderer";

interface Props {
	src: string;
};
const props = defineProps<Props>();

const iframe = ref<HTMLIFrameElement | null>(null);

let client: RendererClient | null = null;

const updateClient = async (newOrigin = false) => {
	await client!.connect(newOrigin);
	await client!.ping();

	const { data: libraries } = await client!.getLibraries();
	setLibraries(libraries);
	setCurrent(libraries[0].slices[0], libraries[0].slices[0].variations[0]);
}

onMounted(async () => {
	if (iframe.value) {
		client = new RendererClient(iframe.value, { debug: true });

		watch(() => props.src, () => updateClient(true));
		await updateClient();
	} else {
		throw new Error("iframe not found");
	}
});

watch(rendererState, async () => {
	if (client) {
		await client.setSliceZoneFromSliceIDs(
			rendererState.value.history.map(({ slice, variation }) => {
				return {
					sliceID: slice.id,
					variationID: variation.id,
				};
			})
		);
	}
}, { deep: true });

const names = computed(() => {
	if (!rendererState.value.current) {
		return {
			slice: "Loading...",
			variation: "Loading...",
		};
	} else {
		return {
			slice: rendererState.value.current.slice.name,
			variation: rendererState.value.current.variation.name,
		};
	}
})
</script>
